<?php

class CustomDeployedRelationships extends DeployedRelationships {

    public function getUniqueName($relationship)
    {
        if($relationship) {
            return $relationship->relationship_name;
        } else {
            return array_keys($this->relationships)[0];
        }
    }

    private function getLabelInstallDefs($relationshipName) {
        return $this->relationships[$relationshipName]->buildLabels();
    }

    public function generateLanguagePacks($basepath, $installDefPrefix, $relationshipName) {
        return $this->saveLabels($basepath, $installDefPrefix, $relationshipName, $this->getLabelInstallDefs($relationshipName));
    }

    private function getRHSLinkName($moduleName) {
        return $_REQUEST['inputLinkFieldNameRight'] ?? $this->newRelationshipName;// . '_' . strtolower($GLOBALS['beanList'][$moduleName]);
    }

    /**
     * @param $vardefs
     * @return mixed
     * @throws Exception
     */
    private function modifyVardefsForManyToMany($vardefs) {

        foreach ($vardefs AS $module => &$moduleVardefs) {

            if($module === $this->relationships[$this->newRelationshipName]->lhs_module) {
                $moduleVardefs[0]['name'] = $_REQUEST['inputLinkFieldNameLeft'];
            } else if($module === $this->relationships[$this->newRelationshipName]->rhs_module) {
                $moduleVardefs[0]['name'] = $_REQUEST['inputLinkFieldNameRight'];
            }

            $moduleVardefs[0]['id_name'] = strtolower($moduleVardefs[0]['bean_name'] . '_id');

            if(count($moduleVardefs) > 1) {
                $moduleVardefs[1]['name'] = $_REQUEST['inputLinkFieldNameRight'];
                $moduleVardefs[1]['id_name'] = strtolower($moduleVardefs[0]['bean_name'] . '_id2');
            }
        }

        return $vardefs;
    }

    private function modifyVardefsForOneToMany($vardefs) {
        foreach ($vardefs AS $module => &$fields) {
            foreach ($fields AS $index => &$field) {
                if($field['type'] === 'link') {

                    if($field['link-type'] === 'many') {
                        $field['id_name'] = 'id';
                        $field['name'] = $_REQUEST['inputLinkFieldNameLeft'];
                    } elseif($field['link-type'] === 'one') {
                        $field['id_name'] = $_REQUEST['inputLinkFieldNameRight'].'_id';
                        $field['name'] = $_REQUEST['inputLinkFieldNameRight'];
                    }
                } elseif($field['type'] === 'relate') {
                    $field['name'] = $_REQUEST['inputLinkFieldNameRight'] . '_name';
                    $field['id_name'] = $_REQUEST['inputLinkFieldNameRight'] . '_id';
                    $field['link'] = $_REQUEST['inputLinkFieldNameRight'];
                } elseif($field['type'] === 'id') {

                    unset($field['source']);
                    unset($field['id_name']);
                    unset($field['rname']);
                    unset($field['table']);
                    unset($field['module']);
                    unset($field['link']);

                    $field['name'] = $_REQUEST['inputLinkFieldNameRight'] . '_id';
                }
            }
        }

        return $vardefs;
    }

    public function saveFieldsToLayouts($basepath, $dummy, $relationshipName, $layoutAdditions)
    {
        $customLayoutAdditions = [];

        foreach ($layoutAdditions AS $module => $field) {

            $fieldName = 'inputLinkFieldName';

            if($_REQUEST['lhs_module'] === $module && $_REQUEST['lhs_module'] !== $_REQUEST['rhs_module']) {
                $fieldName .= 'Left';
            } else if($_REQUEST['rhs_module'] === $module) {
                $fieldName .= 'Right';
            }

            $linkName = $_REQUEST[$fieldName];

            if(!$linkName) {
                throw new Exception(sprintf('Could not find link for module %s and relationship %s', $module, $relationshipName));
            }

            $customLayoutAdditions[$module] = $linkName . '_name';
        }

        parent::saveFieldsToLayouts($basepath, $dummy, $relationshipName, $customLayoutAdditions); // TODO: Change the autogenerated stub
    }

    public function saveSidecarSubpanelDefinitions($basepath, $installDefPrefix, $relationshipName, $subpanelDefinitions, $client = "base")
    {
        foreach ($subpanelDefinitions AS $module => &$definition) {
            $fieldName = 'inputLinkFieldName';

            if($_REQUEST['lhs_module'] === $module) {
                $fieldName .= 'Left';
            } else if($_REQUEST['rhs_module'] === $module) {
                $fieldName .= 'Right';
            }

            $linkName = $_REQUEST[$fieldName];

            if(!$linkName) {
                throw new Exception(sprintf('Could not find link for module %s and relationship %s', $module, $relationshipName));
            }

            $definition[0]['get_subpanel_data'] = $linkName;
        }

        if($this->relationships[$relationshipName]->relationship_type === MB_MANYTOMANY && count($subpanelDefinitions) === 1) {
            $module = array_keys($subpanelDefinitions)[0];
            $subpanelDefinitions[$module][1] = $subpanelDefinitions[$module][0];
            $subpanelDefinitions[$module][1]['get_subpanel_data'] = $_REQUEST['inputLinkFieldNameRight'];
            $subpanelDefinitions[$module][1]['title_key'] = str_replace('_R_', '_L_', $subpanelDefinitions[$module][1]['title_key']);
        }

        return parent::saveSidecarSubpanelDefinitions($basepath, $installDefPrefix, $relationshipName, $subpanelDefinitions);
    }

    /**
     * @param $basepath
     * @param $installDefPrefix
     * @param $relationshipName
     * @param $vardefs
     * @return mixed
     * @throws Exception
     */
    public function saveVardefs($basepath, $installDefPrefix, $relationshipName, $vardefs)
    {
        $relationType = $this->relationships[$relationshipName]->relationship_type;

        if($relationType === 'one-to-many') {
            $vardefs = $this->modifyVardefsForOneToMany($vardefs);
        } else if($relationType === 'one-to-one') {
            $vardefs = $this->modifyVardefsForOneToOne($vardefs);
        } else if($relationType === 'many-to-many') {
            $vardefs = $this->modifyVardefsForManyToMany($vardefs);
        }

        return parent::saveVardefs($basepath, $installDefPrefix, $relationshipName, $vardefs);
    }

    function save ($rebuildMetadata = true)
    {
        // Rebuild the relationship portion of the metadata cache if requested
        if ($rebuildMetadata) {
            MetaDataManager::refreshSectionCache(array(MetaDataManager::MM_RELATIONSHIPS));
        }
    }

    public function saveRelationshipMetaData($basepath, $installDefPrefix, $relationshipName, $relationshipMetaData)
    {
        $relationType = $this->relationships[$relationshipName]->relationship_type;

        if($relationType === 'one-to-many') {
            $relationshipMetaData = $this->modifyRelationshipForOneToMany($relationshipMetaData, $relationshipName);
        } else {
            $relationshipMetaData = $this->modifyRelationshipForManyToMany($relationshipMetaData, $relationshipName);
        }

        return parent::saveRelationshipMetaData($basepath, $installDefPrefix, $relationshipName, $relationshipMetaData);
    }

    function addFromPost ()
    {
        $definition = array ( ) ;

        foreach (AbstractRelationship::$definitionKeys as $key) {
            if (!empty($_REQUEST[$key])) {
                if (in_array($key, array('label', 'rhs_label', 'lhs_label'))) {
                    $definition[$key] = htmlspecialchars_decode($_REQUEST[$key], ENT_QUOTES);
                } else if ($key == 'relationship_type') {
                    $definition[$key] = AbstractRelationship::parseRelationshipType($_REQUEST[$key]);
                } else {
                    $definition[$key] = $_REQUEST[$key];
                }
            }
        }

        // if this is a change to an existing relationship, and it is not readonly, then delete the old one
        if (! empty ( $_REQUEST [ 'relationship_name' ] ))
        {
            if ($relationship = $this->get ( $_REQUEST [ 'relationship_name' ] ))
            {
                unset( $definition[ 'relationship_name' ] ) ; // in case the related modules have changed; this name is probably no longer appropriate
                if (! $relationship->readonly ())
                    $this->delete ( $_REQUEST [ 'relationship_name' ] ) ;
            }
        }

        $newRelationship = RelationshipFactory::newRelationship ( $definition ) ;
        // TODO: error handling in case we get a badly formed definition and hence relationship
        $this->add ( $newRelationship ) ;
        return $newRelationship ;
    }

    private function removeFieldsFromDeployedLayout($relationship)
    {
        // many-to-many relationships don't have fields so if we have a many-to-many we can just skip this...
        if ($relationship->getType () == MB_MANYTOMANY)
            return false ;

        $successful = true ;
        $layoutAdditions = $relationship->buildFieldsToLayouts () ;

        foreach ( $layoutAdditions as $deployedModuleName => $fieldName )
        {
            // Handle decision making on views for BWC/non-BWC modules
            if (isModuleBWC($deployedModuleName)) {
                $views = array(MB_EDITVIEW, MB_DETAILVIEW);
            } else {
                $views = array(MB_RECORDVIEW);
            }

            $fieldName = 'inputLinkFieldName';

            if($relationship->lhs_module === $deployedModuleName && $relationship->lhs_module !== $relationship->rhs_module) {
                $fieldName .= 'Left';
            } else if($relationship->rhs_module === $deployedModuleName) {
                $fieldName .= 'Right';
            }

            $linkName = $_REQUEST[$fieldName];

            if(!$linkName) {
                throw new Exception(sprintf('Could not find link for module %s and relationship %s', $deployedModuleName, $relationship->relationship_name));
            }

            $fieldName = $linkName . '_name';

            foreach($views as $view) {
                $parser = ParserFactory::getParser($view, $deployedModuleName);
                $parser->removeField ( $fieldName );
                $parser->handleSave ( false ) ;
            }
        }

        return $successful ;
    }

    private function modifyRelationshipForManyToMany($relationshipMetaData, $relationshipName)
    {
        $primaryModule = array_keys($relationshipMetaData)[0];
        $origTable = $relationshipMetaData[$primaryModule]['table'];

        if(substr($origTable, strlen($origTable) - 2, 2) === '_c') {
            $relationshipMetaData[$primaryModule]['table'] = substr($origTable, 0, -2);
        }

        $oldLhsJoinField = $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['join_key_lhs'];
        $oldRhsJoinField = $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['join_key_rhs'];

        $newLhsJoinField = strtolower($GLOBALS['beanList'][$relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['lhs_module']] . '_id');
        $newRhsJoinField = strtolower($GLOBALS['beanList'][$relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['rhs_module']] . '_id');

        if($newLhsJoinField === $newRhsJoinField) {
            $newRhsJoinField .= '2';
        }

        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['join_key_lhs'] = $newLhsJoinField;
        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['join_key_rhs'] = $newRhsJoinField;
        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['join_table'] = $relationshipMetaData[$primaryModule]['table'];

        $relationshipMetaData[$primaryModule]['fields'][$newLhsJoinField] = $relationshipMetaData[$primaryModule]['fields'][$oldLhsJoinField];
        $relationshipMetaData[$primaryModule]['fields'][$newLhsJoinField]['name'] = $newLhsJoinField;

        $relationshipMetaData[$primaryModule]['fields'][$newRhsJoinField] = $relationshipMetaData[$primaryModule]['fields'][$oldRhsJoinField];
        $relationshipMetaData[$primaryModule]['fields'][$newRhsJoinField]['name'] = $newRhsJoinField;

        unset($relationshipMetaData[$primaryModule]['fields'][$oldLhsJoinField]);
        unset($relationshipMetaData[$primaryModule]['fields'][$oldRhsJoinField]);

        foreach ($relationshipMetaData[$primaryModule]['indices'] AS &$indexDefinition) {
            foreach ([$oldLhsJoinField => $newLhsJoinField, $oldRhsJoinField => $newRhsJoinField] AS $oldFieldName => $newFieldName) {
                $indexDefinition['name'] = str_replace($oldFieldName, $newFieldName, $indexDefinition['name']);
                foreach ($indexDefinition['fields'] AS $indexPos => $indexFieldName) {
                    $indexDefinition['fields'][$indexPos] = str_replace($oldFieldName, $newFieldName, $indexFieldName);
                }
            }
        }

        return $relationshipMetaData;
    }

    private function modifyRelationshipForOneToMany($relationshipMetaData, $relationshipName)
    {
        $primaryModule = array_keys($relationshipMetaData)[0];

        foreach (['true_relationship_type', 'table', 'fields'] AS $attribute) {
            unset($relationshipMetaData[$primaryModule][$attribute]);
        }

        foreach (['join_table', 'join_key_lhs', 'join_key_rhs'] AS $attribute) {
            unset($relationshipMetaData[$primaryModule]['relationships'][$relationshipName][$attribute]);
        }

        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['relationship_type'] = 'one-to-many';
        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['lhs_key'] = 'id';
        $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['rhs_key'] = $this->getRHSLinkName($relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['rhs_module']) . '_id';

        $relationshipMetaData[$primaryModule]['indices'] = [[
            'name' => 'idx_' . $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['rhs_key'],
            'type' => 'index',
            'fields' => [
                $relationshipMetaData[$primaryModule]['relationships'][$relationshipName]['rhs_key'],
                'deleted'
            ]
        ]];

        return $relationshipMetaData;
    }

    public function saveLabels($basepath, $installDefPrefix, $relationshipName, $labelDefinitions)
    {
        $installDefs = parent::saveLabels($basepath, $installDefPrefix, $relationshipName, $labelDefinitions); // TODO: Change the autogenerated stub

        $relevantModules = array_unique(array_map(function ($item) {
            return $item['module'];
        }, $labelDefinitions));

        $disabledLanguages = explode(',', SugarConfig::getInstance()->get('disabled_languages'));

        foreach ($relevantModules AS $module) {
            foreach ($disabledLanguages AS $disabledLanguage) {
                if(isset($installDefs[$module.'_'.$disabledLanguage])) {
                    unset($installDefs[$module.'_'.$disabledLanguage]);
                }
            }
        }

        return $installDefs;
    }

    function delete ($rel_name)
    {
        $this->newRelationshipName = $rel_name;

        //Remove any fields from layouts
        $rel = $this->get($rel_name);
        if (!empty($rel))
        {
            $this->removeFieldsFromDeployedLayout($rel);
        }
        SugarAutoLoader::requireWithCustom('ModuleInstall/ModuleInstaller.php');
        $moduleInstallerClass = SugarAutoLoader::customClass('ModuleInstaller');
        $mi = new $moduleInstallerClass();
        $mi->silent = true;
        $mi->uninstall_relationship("custom/metadata/{$rel_name}MetaData.php");

        // now clear all caches so that our changes are visible
        $mi->rebuild_tabledictionary();
        SugarRelationshipFactory::rebuildCache();


        $MBmodStrings = $GLOBALS [ 'mod_strings' ];
        $GLOBALS['reload_vardefs'] = true;
        $GLOBALS [ 'mod_strings' ] = return_module_language ( '', 'Administration' ) ;
        $rac = new RepairAndClear ( ) ;
        $rac->repairAndClearAll ( array ( 'clearAll', 'rebuildExtensions',  ), array ( $GLOBALS [ 'mod_strings' ] [ 'LBL_ALL_MODULES' ] ), true, false, '' ) ;
        $GLOBALS [ 'mod_strings' ] = $MBmodStrings;

        //Bug 41070, supercedes the previous 40941 fix in this section
        if (isset($this->relationships[$rel_name]))
        {
            unset($this->relationships[$rel_name]);
        }
    }

    public function cleanUnusedFiles($path) {

        // Check for files
        if (is_file($path)) {

            // If it is file then remove by
            // using unlink function
            unlink($path);
        }

        // If it is a directory.
        elseif (is_dir($path)) {

            // Get the list of the files in this
            // directory
            $scan = glob(rtrim($path, '/').'/*');

            // Loop through the list of files
            foreach($scan as $index=>$subPath) {

                // Call recursive function
                $this->cleanUnusedFiles($subPath);
            }

            // Remove the directory itself
            @rmdir($path);
        }
    }
}
